#!/usr/bin/env python3
import sys, os, time, hashlib, struct
import serial, serial.tools.list_ports

# --- Crypto import that works with both pip and apt installs ---
try:
    from Crypto.Cipher import AES
    from Crypto.Random import get_random_bytes
except ImportError:
    from Cryptodome.Cipher import AES
    from Cryptodome.Random import get_random_bytes

# =========================
# Constants / Header format
# =========================
MAGIC = b"SX1"       # 3 bytes
VERSION = 1          # 1 byte
HDR_LEN = 3 + 1 + 9 + 16  # MAGIC + VER + ID(9) + IV(16) = 29 bytes total

CMD_STATUS = 0x00
CMD_LOCK   = 0x01
CMD_CRYPTO = 0x02     # expects 9-byte ID payload

# ======================================
# File-ID based purely on inode + device
# ======================================
def file_id_from_inode(path: str) -> bytes:
    """
    9-byte ID derived ONLY from (st_dev, st_ino).
    - Stable across rename.
    - Changes if copied (new inode) or moved across devices.
    """
    st = os.stat(path)
    packed = struct.pack("QQ", st.st_dev, st.st_ino)  # 16 bytes
    h = hashlib.sha256(packed).digest()
    return h[:9]

# ==================
# USB/CDC primitives
# ==================
def build_packet(command: int, payload: bytes = b"") -> bytes:
    return bytes([command]) + payload

def hexdump(buf: bytes) -> str:
    return " ".join(f"0x{b:02X}" for b in buf)

def detect_device(baud=115200) -> str | None:
    print("üîç Scanning serial ports for SecureX device...")
    for p in serial.tools.list_ports.comports():
        try:
            with serial.Serial(p.device, baudrate=baud, timeout=1) as ser:
                time.sleep(0.2)
                pkt = build_packet(CMD_STATUS)
                ser.write(pkt); ser.flush()
                time.sleep(0.2)
                resp = ser.read(33)
                if len(resp) == 33:
                    print(f"‚úÖ Found SecureX device on {p.device}")
                    # interpret_status(resp)
                    return p.device
        except Exception:
            continue
    print("‚ùå No SecureX device detected.")
    return None

def send_and_recv(port: str, pkt: bytes, expect: int, baud=115200) -> bytes:
    with serial.Serial(port, baudrate=baud, timeout=2) as ser:
        time.sleep(0.2)
        ser.write(pkt); ser.flush()
        return ser.read(expect)

# =================
# Status utilities
# =================
def interpret_status(resp: bytes) -> None:
    if len(resp) < 1:
        print("‚ö†Ô∏è  Empty status response.")
        return
    code = resp[0]
    if code == 2:
        txt = "BRAND NEW"
        icon = "üÜï"
    elif code == 1:
        txt = "UNLOCKED"
        icon = "üîì"
    elif code == 0:
        txt = "LOCKED"
        icon = "üîí"
    else:
        txt = f"UNKNOWN ({code})"
        icon = "‚ùì"
    print(f"{icon}  Device status: {txt}")

# ==========================
# Get 32-byte key (two ways)
# ==========================
def get_key_from_device_with_id(port: str, file_id9: bytes) -> bytes:
    """
    Ask hardware for a key using a provided 9-byte ID (used during encrypt/decrypt).
    If device is locked and doesn't return a key, automatically check status and
    exit gracefully instead of raising a crash.
    """
    pkt = build_packet(CMD_CRYPTO, file_id9)
    # print(f"‚û°Ô∏è  Sending CRYPTO command (cmd=0x{CMD_CRYPTO:02X}) with ID({len(file_id9)}B): {file_id9.hex()}")
    # print(f"    Packet bytes: {hexdump(pkt)}")

    # --- Send CRYPTO command and wait up to 2s for key ---
    resp = send_and_recv(port, pkt, 64)

    # --- No key received? Send status command ---
    if len(resp) < 32:
        print("‚ö†Ô∏è  No key received from device within timeout. Checking device status...")
        status_pkt = build_packet(CMD_STATUS)
        status_resp = send_and_recv(port, status_pkt, 33)

        if len(status_resp) == 33:
            code = status_resp[0]
            if code == 0:
                print("üîí  Device is LOCKED. Unlock it before encrypt/decrypt.")
                sys.exit(0)
            elif code == 1:
                print("‚ùì  Unknown error: Device is UNLOCKED but did not return a key.")
                # print("   Raw status bytes:", hexdump(status_resp))
                sys.exit(1)
            elif code == 2:
                print("üÜï  Device is BRAND NEW ‚Äî not initialized yet.")
                # print("   Raw status bytes:", hexdump(status_resp))
                sys.exit(1)
            else:
                print(f"‚ùì  Unexpected status code: {code}")
                # print("   Raw status bytes:", hexdump(status_resp))
                sys.exit(1)
        else:
            print("‚ö†Ô∏è  No valid status response received (device not responding).")
            sys.exit(1)

    # --- Valid key received ---
    key = resp[:32]
    # print(f"üîë Device key (32B): {key.hex()}")
    return key

# ================================
# AES-256-CBC encrypt / decrypt
# with header [MAGIC|VER|ID|IV]
# ================================
def aes_encrypt_file_with_header(in_path: str, key: bytes, file_id9: bytes) -> str:
    iv = get_random_bytes(16)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    out_path = in_path + ".enc"

    # print(f"üßæ Header:")
    # print(f"    MAGIC: {MAGIC}")
    # print(f"    VERSION: {VERSION}")
    # print(f"    FILE ID (9B): {file_id9.hex()}")
    # print(f"    IV (16B): {iv.hex()}")

    with open(in_path, "rb") as fin, open(out_path, "wb") as fout:
        # Write header
        fout.write(MAGIC)
        fout.write(bytes([VERSION]))
        fout.write(file_id9)   # 9 bytes
        fout.write(iv)         # 16 bytes

        # Stream encrypt with PKCS#7 padding per chunk (last chunk gets padding)
        while True:
            chunk = fin.read(4096)
            if not chunk:
                # write a full padding block if file size multiple of 16
                pad_len = 16
                pad = bytes([pad_len]) * pad_len
                fout.write(cipher.encrypt(pad))
                break
            if len(chunk) % 16 != 0:
                pad_len = 16 - (len(chunk) % 16)
                chunk += bytes([pad_len]) * pad_len
                fout.write(cipher.encrypt(chunk))
                break
            else:
                fout.write(cipher.encrypt(chunk))

    print(f"‚úÖ Encrypted file saved as: {out_path}")
    return out_path

def aes_decrypt_file_with_header(enc_path: str, port: str) -> str:
    with open(enc_path, "rb") as fin:
        header = fin.read(HDR_LEN)
        if len(header) != HDR_LEN:
            print("‚ùå Encrypted file header too short or corrupt.")
            sys.exit(1)

        magic = header[:3]
        ver = header[3]
        file_id9 = header[4:13]
        iv = header[13:29]
        ciphertext = fin.read()

    if magic != MAGIC:
        print("‚ùå Invalid MAGIC header ‚Äî not a SecureX file.")
        sys.exit(1)
    if ver != VERSION:
        print(f"‚ùå Unsupported file version: {ver}")
        sys.exit(1)

    # print(f"üßæ Parsed header:")
    # print(f"    MAGIC: {magic}")
    # print(f"    VERSION: {ver}")
    # print(f"    FILE ID (9B): {file_id9.hex()}")
    # print(f"    IV (16B): {iv.hex()}")

    # --- Ask hardware for key ---
    key = get_key_from_device_with_id(port, file_id9)

    # --- Try decryption safely ---
    try:
        cipher = AES.new(key, AES.MODE_CBC, iv)
        if len(ciphertext) == 0 or len(ciphertext) % 16 != 0:
            print("‚ùå Ciphertext size invalid; file may be corrupt.")
            sys.exit(1)

        plaintext = cipher.decrypt(ciphertext)

        # Validate padding (PKCS#7)
        pad_len = plaintext[-1]
        if not (1 <= pad_len <= 16):
            raise ValueError("Invalid padding length")
        if plaintext[-pad_len:] != bytes([pad_len]) * pad_len:
            raise ValueError("Padding bytes incorrect")

        plaintext = plaintext[:-pad_len]

    except ValueError as e:
        # Likely caused by wrong user key (bad padding)
        print("‚ùå Decryption failed ‚Äî possibly wrong user or corrupted file.")
        # print("   Details:", str(e))
        # print("   The current hardware user likely differs from the one who encrypted this file.")
        sys.exit(1)
    except Exception as e:
        print("‚ùå Unknown error during decryption:", e)
        sys.exit(1)

    # --- Save successfully decrypted file ---
    if enc_path.endswith(".enc"):
        out_path = enc_path[:-4]
    else:
        out_path = enc_path + ".dec"

    with open(out_path, "wb") as fout:
        fout.write(plaintext)
    print(f"‚úÖ Decrypted file saved as: {out_path}")
    return out_path


# ===========
# Main / CLI
# ===========
def usage():
    print("Usage:")
    print("  python3 SecureX.py status")
    print("  python3 SecureX.py lock")
    print("  python3 SecureX.py encrypt <file>")
    print("  python3 SecureX.py decrypt <file.enc>")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        usage(); sys.exit(1)

    cmd = sys.argv[1].lower()

    # Auto-detect device once at start (for commands that need it)
    needs_device = cmd in {"status", "lock", "encrypt", "decrypt"}
    port = None
    if needs_device:
        port = detect_device()
        if not port:
            sys.exit(1)

    if cmd == "status":
        pkt = build_packet(CMD_STATUS)
        # print(f"‚û°Ô∏è  Sending STATUS (cmd=0x{CMD_STATUS:02X}) Packet: {hexdump(pkt)}")
        resp = send_and_recv(port, pkt, 33)
        if len(resp) == 33:
            interpret_status(resp)
            # print("   Raw status bytes:", hexdump(resp))
        else:
            print("‚ö†Ô∏è  No valid status response.")

    elif cmd == "lock":
        pkt = build_packet(CMD_LOCK)
        # print(f"‚û°Ô∏è  Sending LOCK (cmd=0x{CMD_LOCK:02X}) Packet: {hexdump(pkt)}")
        resp = send_and_recv(port, pkt, 33)
        if resp:
            # print("   Lock reply bytes:", hexdump(resp))
            interpret_status(resp)
        else:
            print("‚ö†Ô∏è  No response to lock command.")

    elif cmd == "encrypt":
        if len(sys.argv) < 3:
            usage(); sys.exit(1)
        in_path = sys.argv[2]
        # Compute inode-based ID and fetch key
        fid = file_id_from_inode(in_path)
        key = get_key_from_device_with_id(port, fid)
        # Encrypt with header (MAGIC|VER|ID|IV)
        aes_encrypt_file_with_header(in_path, key, fid)

    elif cmd == "decrypt":
        if len(sys.argv) < 3:
            usage(); sys.exit(1)

        enc_path = sys.argv[2]

        # --- Check if file has .enc extension ---
        if not enc_path.endswith(".enc"):
            # maybe user forgot extension ‚Äî suggest correct name
            candidate = enc_path + ".enc"
            if os.path.isfile(candidate):
                print(f"‚ÑπÔ∏è  You passed '{enc_path}' but the encrypted file is '{candidate}'.")
                print(f"üîÅ Try: SecureX decrypt {candidate}")
            else:
                print(f"‚ùå The file '{enc_path}' is not an encrypted file (.enc expected).")
            sys.exit(1)

        # --- Check file existence ---
        if not os.path.isfile(enc_path):
            print(f"‚ùå File not found: {enc_path}")
            sys.exit(1)

        # --- Proceed with normal decrypt ---
        aes_decrypt_file_with_header(enc_path, port)


    else:
        usage(); sys.exit(1)
